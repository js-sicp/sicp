# 2.81

## a

- 무한 루프에 빠지게 된다.
  - 정의된 연산이 없기에, 코어션 관련 코드로 넘어간다.
  - 코어션에서 그대로 반환하기에 다시 apply_generic 코드가 실행된다.
  - 위 과정이 계속 반복된다.

## b

- 만일 다른 형식간의 연산만 정의되어 있다면, 같은 형식일 때 형변환이 필요하다.
- 하지만 현재의 경우에는 같은 형식의 연산이 정의되어 있으므로 그럴 필요가 없다.

## c

```js
return type1 === type2 ? error(list(op, type_tags), "do not add coercion when the types are same") : ...
```

# 2.82

- 첫 인수로 통일한다고 하였을 때, 만일 첫 인수가 정수이고 두 번째 인수가 복소수라면 복소수는 정수로 변환될 수 없는 상태가 있기 때문에 불가능하다.
- 타워 형태라고 한다면, 인수 중 가장 상위 계층의 표현으로 통일해주는 방식이면 오류가 없을 것으로 보인다.

# 2.83

```js
function raise_num_to_rat(n) {}
```

- 복소수를 제외한 수 패키지들은 raise 함수를 보유하고 있다.
- 정수는 유리수로, 유리수는 실수로, 실수는 복소수로 승격시킨다.

# 2.84

- 위계 질서가 있다면 문제의 해결은 간단하다. 비교를 할 필요없이 최상위 레벨로 통일시키면 되기 때문이다.
- 하지만 위계 질서가 없다면, 결국에는 트리 형태의 데이터가 필요하다. 트리 형태의 데이터가 없다면 각 패키지마다 모든 표현 방식에 대해서 비교를 해주어야 하는데 이는 가산성에 어긋난다. 새로운 표현이 들어갈 경우 기존의 모든 패키지의 표현 연산들의 수정이 필요하다.
  - 자신의 위치를 기점으로 부모를 타고 올라가는 탐색을 하면서 자신보다 상위인지 판단한다.
  - 자신의 위치를 기점으로 자식을 타고 내려가는 탐색을 하면서 자신보다 하위인지 판단한다.

# 2.85

- project로 내렸다가 raise를 했을 때 이전과 같다면 내릴 수 있는 것이다.
- 완전 깔끔한 인터페이스이다.
