# 3.38

## a

- 피터, 폴, 메리: 110 / 90 / 45
- 피터, 메리, 폴: 110 / 55 / 35
- 폴, 피터, 메리: 80 / 90 / 45
- 폴, 메리, 피터: 80 / 40 / 50
- 메리, 피터, 폴: 50 / 60 / 40
- 메리, 폴, 피터: 50 / 30 / 40

## b

- 교대로 실행될 경우, transaction이 보장되지 않는 경우 은행 출금을 위한 함수들을 호출하는 수와 동시에 접근하는 스레드의 수에 대한 경우의 수는 (스레드 수 \* 함수 호출 수)P(함수 호출 수)와 같이 매우 많다.
- 따라서 한가지 예시를 통해서 설명하도록 하겠다.
- 피터는 100달러로 잔고를 인식했다. 그리고 10달러를 인출하기 이전에 메리가 잔고에 접근하고 100달러로 인식했다. 그리고 50달러를 인출한다. 피터는 10달러를 더해서 110달러로 업데이트한다. 그리고 폴이 마지막으로 20달러를 인출한다. 90달러가 된다.
- 위의 경우 은행은 큰 손해를 입게된다.

# 3.39

- 조회와 배정이 하나의 작업으로 묶여야 하는데, t1의 경우 조회의 경우 동시성 문제는 없지만, 배정에 있어서 동시성 문제가 생긴다.
- 그러면 다음과 같은 문제가 발생할 수 있다.
  - t1이 10으로 조회한다.
  - t2도 직렬화기를 통해서 10으로 조회한다.
  - t2의 배정이 t1에 비해서 먼저 끝난다.
  - t1의 배정이 완료된다. 100으로 배정한다.
  - t2의 배정이 완료된 값이 반영되지 않았기 때문에 위 값은 옳지 않다.

# 3.40

- t1: 조회, 조회, 배정 (a,b,c)
- t2: 조회, 조회, 조회, 배정 (d,e,f,g)
- 이론상 조합 가능한 경우의 수는 125가지이다. a,b,c를 d,e,f,g 앞 뒤 포함하여 끼워넣을 수 있는 경우의 수와 동일하다.
- 하지만 이론상 조합 가능한 경우의 수를 다 계산하는 것은 비효율적이다.
- transaction이 보장되지 않음으로써 발생할 수 있는 경우의 수는 적기 때문이다.
- 각 조회 상태에 대해서 상대방의 배정이 일어났다고 가정하고 모든 수를 계산해보면 된다.

# 3.41

- 배정이 일어나지 않는 조회는 직렬화기에 굳이 넣을 필요는 없다.
- 그리고 배정이 필요한 조회의 경우 withdraw, deposit에 존재하기 때문에 굳이 넣을 필요는 없다.

# 3.42

- 첫 번째 버전은 protect 함수가 dispatch가 일어날 때마다 호출된다.
- 두 번째 버전은 protect 함수가 한번만 일어난다.
- 동작에는 차이가 없다. 이미 같은 직렬화기 집합에 포함되었기 때문이다.

# 3.43

- 계좌의 차액을 교환하는 것이기 때문에, 두 계좌의 총액이 변경된다고 할 수 있다. 같은 집합 내에서 잔액 교환을 수행한다고 할 때 다른 총액이 있는 계좌는 생성될 수 없다.
- 하나의 계좌를 접근을 제한할 때

  - 10, 20, 30 잔액이 존재하는 계좌를 a,b,c 라고 한다.
  - (a,b), (b,c) 두 개의 배치가 수행된다고 가정한다.
    - (a,b)의 diff가 10으로 판단하고, a에 10을 보내려고 한다.
    - (b,c)의 배치가 먼저 완료된다. b는 30, c는 20이 되었다.
    - 이 상태에서 a로 10을 보낸다. b는 20 a 는 20 c는 20이 된다.
    - 잔액의 총량이 보장되는 이유는, 조회와 배정이 하나의 transaction이다. 인출과 입금을 각각 마이너스 연산, 플러스 연산으로 치환했을 때 마이너스 연산, 플러스 연산은 교환 법칙이 성립한다. 즉 어느 순서로 연산하더라도 결과는 동일하다.
  - 개별 계좌를 직렬화 하지 않을 때
    - 3.38의 문제를 통해 직렬화하지 않는다면 하나의 계좌에서 동시성을 고려할 때 잘못된 금액을 도출할 수 있다는 결과를 얻었다. exchange는 두 계좌간 상호작용이기 때문에 한 계좌가 잘못된 금액이 도출될 수 있다면 exchange를 통해 계산된 결과 또한 잘못된 금액이 도출될 수 있다.

# 3.44

- 상대 계좌의 접근
-
- 데드락이 발생하게 된다.
