# 1.1. 프로그래밍의 기본 요소

## 목차

1. 표현식
2. 이름 붙이기와 환경
3. 연산자 조합의 평가
4. 복합 함수
5. 함수 적용의 치환 모형
6. 조건부 표현식과 술어
7. 예제: 뉴턴 방법으로 제곱근 구하기
8. 블랙박스 추상으로서의 함수

## 0. 프로그래밍 언어의 3요소

- 원시 표현식 : 언어와 관련한 단순한 개체(entity)
- 조합 수단 : 단순한 요소들로부터 복합적인 요소를 만드는데 쓰인다
- 추상화 수단 : 복합적 요소들에 이름을 붙여 하나의 단위로 다루는데 쓰인다

## 1. 표현식

사람이 JavaScript 문장(statement)을 입력 -> JS 해석기는 이 문장을 평가(evaluation)하여 결과를 화면에 표시

표현식(expression) 문장 = 표현식 + ;

- 표현식 예) `원시 표현식` - 숫자
- `486;` 입력 -> 486 출력
- `복합 표현식` - 숫자 표현식을 + 같은 연산자로 조합 가능
- `12 + 34;` 입력 -> 36 출력

### REPL

read-evaluate-print loop

- 자바스크립트 인터프리터의 동작원리를 뜻함
- JS REPL은 출력을 위해 별도의 명령어가 필요하지 않으므로 인터프리터가 주어진 표현식의 평가 결과를 바로 출력

## 2. 이름 붙이기와 환경

복합적인 연산의 결과를 간단한 이름으로 지칭(상수 선언) -> 기초적인 추상화 수단

- 예) 원주 구하기

```js
const pi = 3.14159;
const radius = 10;
const circumference = 2 * pi * radius;
circumference; // 62.8318
```

이름 - 값 연관시켜 이름으로 값을 불러오기 위해 메모리 공간(환경 - environment)이 필요

## 3. 연산자 조합의 평가

조합의 피연산자 표현식들을 재귀적으로 평가

- 예) `(2 + 4 * 6) * (3 + 12);`

```
트리 누산
         390
           |
    26 --- * --ㄱ
  |   24        15
 |     |         |
(2 + 4 * 6) * (3 + 12)
```

선언에서는 평가 규칙이 다름

- `const x = 3;` 에서 = 은 대입 역할을 함
- const 는 키워드

## 4. 복합 함수

자바스크립트에서 프로그래밍 언어의 3요소

- 수치와 산술 연산 : 원시 데이터(숫자), 원시 함수(+, \* ..)
- 조합의 중첩 : 연산들의 조합
- 추상화 수단 : 이름과 값 연관시키는 상수 선언(const)

복합 함수 예시

```js
function square(x) {
  // function 이름(매개변수)
  return x * x; // return 표현식
}

// 다른 함수를 정의하는 구축 요소로 사용 가능
function sumOfSquare(x, y) {
  return square(x) + square(y);
}
```

## 5. 함수 적용의 치환 모형

해석기의 함수 평가 과정

- 원시 함수

1. 함수 코드 평가
2. 함수 표현식의 값을 인수들에 적용

- 복합 함수

1. 각 매개변수를 해당 인수로 치환
2. 함수 반환 표현식을 평가

치환 모형 (대입 모형)

- 함수 적용의 의미를 결정 (실행 콘텍스트)
- 해석기가 반드시 이런 식으로 작동한다는 것은 아니며 실제로는 로컬 스코프를 따름

인수 우선 평가

- 함수와 인수 표현식을 먼저 평가하고 그 결과로 얻은 함수를 인수들에 적용
- (JS 채택 방식) : 일반적으로 정상 순서 평가가 더 복잡하고 비효율적

정상 순서 평가

- 인수의 값이 실제로 필요해질 때까지 인수 표현식의 평가를 미룸
  - 이 때는 대입만 해놓고 연산자들과 원시 함수들만 관여하는 표현식을 평가할 때가 되면 비로소 인수 표현식을 평가
- 같은 표현식이 여러번 평가되어 비효율 존재

(두 평가 방법 모두 같은 값을 반환)

## 6. 조건부 표현식과 술어

1.

```js
// 조건부 표현식으로 절댓값 구하기
function abs(x) {
  //      술어 ? 귀결표현식 : 대안표현식
  return x >= 0 ? x : -x;
  // 1. 먼저 술어가 평가되고 참, 거짓 결과에 따라 귀결 or 대안 표현식의 결과가 조건부 표현식 전체의 값으로 반환됨
}

// 중첩된 형태
function abs1(x) {
  return x > 0 // x가 0보다 크면
    ? x // x 반환
    : x === 0 // x가 0이면
    ? 0 // 0 반환
    : -x; // 모두 아니면 -x 반환
}
```

2. 표현식1 && 표현식2 : 논리곱(and)

- `표현식1 ? 표현식2 : false`

3. 표현식1 || 표현식2 : 논리합(or)

- `표현식1 ? true : 표현식2`

4. !표현식

- 2, 3과 다르게 우항부터 평가

## 7. 뉴턴 방법(Newton's Method)으로 제곱근 구하기

- 가장 흔히 쓰이는 제곱근을 구하는 방법
- Math.sqrt() 를 따라해보자

![뉴턴 방법](./img/newtons-method.jpg)

<details>
  <summary>./sqrt-iterative</summary>

```js
// prettier-ignore
function sqrtIter(guess, x, count = 0) {
  console.log(++count);
  // 재귀적 반복을 통해 추측값을 실제 제곱근에 가깝게 만듬
  return isGoodEnough(guess, x)
    ? guess
    : sqrtIter(improve(guess, x), x, count);
}

// 정확도를 개선하기 위해 추측값을 업데이트
function improve(guess, x) {
  return average(guess, x / guess);
}

// 산술 평균 구하기
function average(x, y) {
  return (x + y) / 2;
}

// 오차가 0.001 보다 작으면 정확하다고 판단
function isGoodEnough(guess, x) {
  return Math.abs(guess * guess - x) < 0.001;
}

console.log(sqrtIter(1, 2));
/*
실행 횟수: 1 추측값: 1
실행 횟수: 2 추측값: 1.5
실행 횟수: 3 추측값: 1.4166666666666665
실행 횟수: 4 추측값: 1.4142156862745097
1.4142156862745097
 */
```

</details>

## 8. 블랙박스 추상으로서의 함수